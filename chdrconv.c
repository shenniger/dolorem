#include <alloca.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <clang-c/Index.h>

const char *PREAMBLE =
    "# This file has been autogenerated from %s by chdrconv.c.\n"
    "# Do not change it manually!\n";

struct Arg {
  const char *Name;
  CXType Type;
};

static void writeType(CXType a, const char *name) {
  switch (a.kind) {
#define TYPE(name, k)                                                          \
  case CXType_##name:                                                          \
    printf k;                                                                  \
    break;

    TYPE(Void, ("void"))
    TYPE(Bool, ("i8"))
    TYPE(Char_U, ("char"))
    TYPE(UChar, ("u8"))
    TYPE(UShort, ("u16"))
    TYPE(UInt, ("u32"))
    TYPE(ULong, ("u32"))
    TYPE(ULongLong, ("u64"))
    TYPE(Char_S, ("char"))
    TYPE(SChar, ("i8"))
    TYPE(Short, ("i16"))
    TYPE(Int, ("i32"))
    TYPE(Long, ("i32"))
    TYPE(LongLong, ("i64"))
    TYPE(Float, ("sfloat"))
    TYPE(Double, ("float"))
    TYPE(LongDouble, ("lfloat"))
  /*  TYPE(Record, )
  TYPE(Enum, )
  TYPE(Typedef, )
  */
  case CXType_IncompleteArray: {
    CXType pointee = clang_getArrayElementType(a);
    if (pointee.kind != CXType_Void) {
      printf("(ptr ");
      writeType(pointee, name);
      printf(")");
    } else {
      printf("ptr");
    }
    break;
  }

  case CXType_Pointer: {
    CXType pointee = clang_getPointeeType(a);
    if (pointee.kind != CXType_Void) {
      printf("(ptr ");
      writeType(pointee, name);
      printf(")");
    } else {
      printf("ptr");
    }
    break;
  }
  case CXType_Enum:
  case CXType_ConstantArray:
  case CXType_Typedef:
    printf("%s", clang_getCString(clang_getTypeSpelling(a)));
    break;
  case CXType_Elaborated:
    writeType(clang_Type_getNamedType(a), name);
    break;
  case CXType_Record:
  case CXType_FunctionProto:
    printf("i32");
    fprintf(stderr, "# WARN: Currently unsupported type %s\n",
            clang_getCString(clang_getTypeSpelling(a)));
    break;
  default:
    fprintf(stderr, "ERR: unknown type (%i) in %s: %s!\n", (int)a.kind, name,
            clang_getCString(clang_getTypeSpelling(a)));
    exit(1);
    break;
  }
}

static void writeFun(CXType rettype, const char *name, struct Arg *args,
                     unsigned numargs) {
  printf("funproto %s (", name);
  for (unsigned i = 0; i < numargs; ++i) {
    printf("(");
    writeType(args->Type, name);
    printf(" %s) ", args->Name);
  }
  printf(") ");
  writeType(rettype, name);
  printf(";\n");
}

static void writeLocation(CXCursor cursor) {
  CXSourceLocation a = clang_getCursorLocation(cursor);
  CXFile file;
  unsigned line, column;
  clang_getSpellingLocation(a, &file, &line, &column, NULL);
  printf("# Found in %s:%u:%u\n", clang_getCString(clang_getFileName(file)),
         line, column);
}

static enum CXChildVisitResult visitor(CXCursor cursor, CXCursor parent,
                                       CXClientData client_data) {
  enum CXCursorKind kind;

  (void)parent, (void)client_data;

  kind = clang_getCursorKind(cursor);
  if (kind == CXCursor_FunctionDecl) {
    CXType rettype = clang_getResultType(clang_getCursorType(cursor));
    unsigned num = clang_Cursor_getNumArguments(cursor);
    struct Arg *args = alloca(sizeof(struct Arg) * num);
    for (unsigned i = 0; i < num; ++i) {
      CXCursor a = clang_Cursor_getArgument(cursor, i);
      args[i].Name = clang_getCString(clang_getCursorSpelling(a));
      args[i].Type = clang_getCursorType(a);
    }
    writeLocation(cursor);
    writeFun(rettype, clang_getCString(clang_getCursorSpelling(cursor)), args,
             num);
  } else if (kind == CXCursor_VarDecl) {
    /* TODO */
  } else if (kind == CXCursor_EnumDecl) {
    if (!clang_Cursor_isAnonymous(cursor)) {
      writeLocation(cursor);
      printf("create-alias %s ",
             clang_getCString(clang_getCursorSpelling(cursor)));
      writeType(clang_getEnumDeclIntegerType(cursor),
                clang_getCString(clang_getCursorSpelling(cursor)));
      printf(";\n");
    }
    /* TODO: print all enum values */
  } else if (kind == CXCursor_TypedefDecl) {
    writeLocation(cursor);
    printf("create-alias %s ",
           clang_getCString(clang_getCursorSpelling(cursor)));
    writeType(clang_getTypedefDeclUnderlyingType(cursor),
              clang_getCString(clang_getCursorSpelling(cursor)));
    printf(";\n");
  }

  return CXChildVisit_Continue;
}

int main(int argc, char **argv) {
  CXIndex index;
  CXTranslationUnit unit;
  CXCursor cursor;
  uint8_t err = 0;
  /*const char *fakeargv[2];

  if (argc != 2) {
    fputs("USAGE: [main header]\n", stderr);
    return 1;
  }*/

  index = clang_createIndex(0, 0);
  /*fakeargv[0] = argv[1];
  fakeargv[1] = "-DDOLOREM_HDR_CONV";*/
  unit = clang_parseTranslationUnit(index, 0, (const char *const *)argv + 1,
                                    argc - 1, 0, 0, CXTranslationUnit_None);
  cursor = clang_getTranslationUnitCursor(unit);

  for (unsigned I = 0, N = clang_getNumDiagnostics(unit); I != N; ++I) {
    CXDiagnostic diag = clang_getDiagnostic(unit, I);
    CXString str =
        clang_formatDiagnostic(diag, clang_defaultDiagnosticDisplayOptions());
    fprintf(stderr, "CLANG: %s\n", clang_getCString(str));
    clang_disposeString(str);
    if (clang_getDiagnosticSeverity(diag) >= CXDiagnostic_Error) {
      err = 1;
    }
  }

  if (err) {
    return 1;
  }

  /* preamble */
  printf(PREAMBLE, argv[1]);

  /* collect all interesting stuff */
  clang_visitChildren(cursor, &visitor, NULL);

  clang_disposeTranslationUnit(unit);
  clang_disposeIndex(index);
  return 0;
}
